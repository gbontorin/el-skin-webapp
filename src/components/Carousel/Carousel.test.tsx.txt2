import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import Carousel from './Carousel';
import { Provider } from 'react-redux';
import { store } from '../../store';
//import { carouselService } from '../../services';

// Declare the mock function here so it is accessible to your tests
const mockUseGetCarouselItemsQuery = jest.fn();

// Mocka o serviço para que ele não faça chamadas de API reais
jest.mock('../../store/api/apiSlice', () => {
  const originalModule = jest.requireActual('../../store/api/apiSlice');
  return {
    ...originalModule,
    useGetCarouselItemsQuery: mockUseGetCarouselItemsQuery,
  };
});

// Dados mockados para simular a resposta da API
const mockCarouselItems = [
  {
    id: '1',
    title: 'Título 1',
    subtitle: 'Subtítulo 1',
    description: 'Descrição 1',
    backgroundImage: 'bg1.png',
  },
  {
    id: '2',
    title: 'Título 2',
    subtitle: 'Subtítulo 2',
    description: 'Descrição 2',
    backgroundImage: 'bg2.png',
  },
  {
    id: '3',
    title: 'Título 3',
    subtitle: 'Subtítulo 3',
    description: 'Descrição 3',
    backgroundImage: 'bg3.png',
  },
];

const renderWithProviders = () => {
  return render(
    <Provider store={store}>
      <Carousel />
    </Provider>
  );
};

describe('Carousel', () => {
  // Limpa os mocks antes de cada teste
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // --- Testes de Carregamento e Renderização ---

  it('deve renderizar a mensagem de loading ou um estado vazio inicialmente', async () => {
    mockUseGetCarouselItemsQuery.mockReturnValue({
      data: [],
      isLoading: true,
      error: null,
    });

    renderWithProviders();
    expect(screen.getByText('Carregando...')).toBeInTheDocument(); // Ajuste a mensagem para o que o seu componente exibe
  });

  it('deve renderizar os itens do carrossel após a chamada da API', async () => {
    // Mocka a API para que ela retorne os itens
    mockUseGetCarouselItemsQuery.mockReturnValue({
      data: mockCarouselItems,
      isLoading: false,
      error: null,
    });

    renderWithProviders();

    // O `findByText` espera que o elemento apareça na tela
    const firstTitle = await screen.findByText('Título 1');
    expect(firstTitle).toBeInTheDocument();

    expect(screen.getByText('Subtítulo 1')).toBeInTheDocument();
    expect(screen.getByText('Descrição 1')).toBeInTheDocument();
  });

  // --- Testes de Interação do Usuário ---

  it('deve avançar para o próximo item ao clicar no botão "Próximo"', async () => {
    mockUseGetCarouselItemsQuery.mockReturnValue({
      data: mockCarouselItems,
      isLoading: false,
      error: null,
    });
    renderWithProviders();

    const nextButton = await screen.findByRole('button', { name: /próximo/i });

    // O primeiro item é o "Título 1"
    const firstTitle = await screen.findByText('Título 1');
    expect(firstTitle).toBeInTheDocument();

    // Simula o clique
    fireEvent.click(nextButton);

    // O próximo item deve ser o "Título 2"
    const secondTitle = await screen.findByText('Título 2');
    expect(secondTitle).toBeInTheDocument();
  });

  it('deve voltar para o item anterior ao clicar no botão "Voltar"', async () => {
    mockUseGetCarouselItemsQuery.mockReturnValue({
      data: mockCarouselItems,
      isLoading: false,
      error: null,
    });
    renderWithProviders();

    // Avança para o segundo item para que possamos voltar
    const nextButton = await screen.findByRole('button', { name: /próximo/i });
    fireEvent.click(nextButton);
    await screen.findByText('Título 2');

    const prevButton = screen.getByRole('button', { name: /voltar/i });

    // Simula o clique para voltar
    fireEvent.click(prevButton);

    // O item anterior deve ser o "Título 1"
    await screen.findByText('Título 1');
    expect(screen.getByText('Título 1')).toBeInTheDocument();
  });

  it('deve parar a reprodução automática ao passar o mouse', async () => {
    // Usa `jest.useFakeTimers()` para controlar o tempo nos testes
    jest.useFakeTimers();
    mockUseGetCarouselItemsQuery.mockReturnValue({
      data: mockCarouselItems,
      isLoading: false,
      error: null,
    });

    renderWithProviders();

    const carouselSection = await screen.findByRole('region');

    // Item inicial é o "Título 1"
    expect(screen.getByText('Título 1')).toBeInTheDocument();

    // Simula o `mouseEnter`
    fireEvent.mouseEnter(carouselSection);

    // Avança o temporizador, mas o item não deve mudar
    jest.advanceTimersByTime(1000);
    expect(screen.getByText('Título 1')).toBeInTheDocument();

    // Limpa o temporizador
    jest.useRealTimers();
  });

  it('deve retomar a reprodução automática ao retirar o mouse', async () => {
    jest.useFakeTimers();
    mockUseGetCarouselItemsQuery.mockReturnValue({
      data: mockCarouselItems,
      isLoading: false,
      error: null,
    });

    renderWithProviders();

    const carouselSection = await screen.findByRole('region');

    // Inicia e para a reprodução automática
    fireEvent.mouseEnter(carouselSection);
    fireEvent.mouseLeave(carouselSection);

    // Avança o temporizador por 1 segundo
    jest.advanceTimersByTime(1000);

    // O item deve ter mudado para o "Título 2"
    await waitFor(
      () => {
        expect(screen.getByText('Título 2')).toBeInTheDocument();
      },
      { timeout: 100 }
    );

    jest.useRealTimers();
  });

  it('deve chamar a função do botão "comprar agora"', async () => {
    // Mocka o console para verificar se a mensagem foi logada
    const consoleSpy = jest.spyOn(console, 'log');

    mockUseGetCarouselItemsQuery.mockReturnValue({
      data: mockCarouselItems,
      isLoading: false,
      error: null,
    });
    renderWithProviders();

    const comprarAgoraButton = await screen.findByRole('button', {
      name: /comprar agora/i,
    });

    fireEvent.click(comprarAgoraButton);

    expect(consoleSpy).toHaveBeenCalledWith('Botão clicado: Comprar Agora!');

    consoleSpy.mockRestore(); // Restaura o console.log original
  });
});

/*

describe('Carousel', async () => {
  /*
    beforeEach(() => {
    // Limpa os mocks antes de cada teste para evitar interferência
    jest.clearAllMocks();
    });
    
   
   it('deve renderizar a mensagem de loading ou um estado vazio inicialmente', async () => {
    // A chamada à API ainda não foi resolvida, então `carouselItems` está vazio.
    //carouselService.getCarouselItems.mockResolvedValueOnce([]);
    render(<Carousel />);
    
    // Verifique se o carrossel não está no documento.
    const carouselSection = await screen.queryByRole('region');
    expect(true).toBeTruthy;
    //expect(carouselSection).not.toBeInTheDocument();
  });
    
});

/*
});

  /*
  // --- Testes de Carregamento e Renderização ---

  it('deve renderizar a mensagem de loading ou um estado vazio inicialmente', () => {
    // A chamada à API ainda não foi resolvida, então `carouselItems` está vazio.
    carouselService.getCarouselItems.mockResolvedValueOnce([]);
    render(<Carousel />);
    
    // Verifique se o carrossel não está no documento.
    const carouselSection = screen.queryByRole('region');
    expect(carouselSection).not.toBeInTheDocument();
  });

  it('deve renderizar os itens do carrossel após a chamada da API', async () => {
    // Mocka a API para que ela retorne os itens
    carouselService.getCarouselItems.mockResolvedValueOnce(mockCarouselItems);
    render(<Carousel />);
    
    // O `findByText` espera que o elemento apareça na tela
    const firstTitle = await screen.findByText('Título 1');
    expect(firstTitle).toBeInTheDocument();
    
    expect(screen.getByText('Subtítulo 1')).toBeInTheDocument();
    expect(screen.getByText('Descrição 1')).toBeInTheDocument();
  });

  // --- Testes de Interação do Usuário ---

  it('deve avançar para o próximo item ao clicar no botão "Próximo"', async () => {
    carouselService.getCarouselItems.mockResolvedValueOnce(mockCarouselItems);
    render(<Carousel />);

    const nextButton = await screen.findByRole('button', { name: /próximo/i });
    
    // O primeiro item é o "Título 1"
    const firstTitle = await screen.findByText('Título 1');
    expect(firstTitle).toBeInTheDocument();

    // Simula o clique
    fireEvent.click(nextButton);

    // O próximo item deve ser o "Título 2"
    const secondTitle = await screen.findByText('Título 2');
    expect(secondTitle).toBeInTheDocument();
  });

  it('deve voltar para o item anterior ao clicar no botão "Voltar"', async () => {
    carouselService.getCarouselItems.mockResolvedValueOnce(mockCarouselItems);
    render(<Carousel />);
    
    // Avança para o segundo item para que possamos voltar
    const nextButton = await screen.findByRole('button', { name: /próximo/i });
    fireEvent.click(nextButton);
    await screen.findByText('Título 2');

    const prevButton = screen.getByRole('button', { name: /voltar/i });
    
    // Simula o clique para voltar
    fireEvent.click(prevButton);

    // O item anterior deve ser o "Título 1"
    await screen.findByText('Título 1');
    expect(screen.getByText('Título 1')).toBeInTheDocument();
  });

  it('deve parar a reprodução automática ao passar o mouse', async () => {
    // Usa `jest.useFakeTimers()` para controlar o tempo nos testes
    jest.useFakeTimers();
    carouselService.getCarouselItems.mockResolvedValueOnce(mockCarouselItems);
    
    render(<Carousel />);
    
    const carouselSection = await screen.findByRole('region');

    // Item inicial é o "Título 1"
    expect(screen.getByText('Título 1')).toBeInTheDocument();

    // Simula o `mouseEnter`
    fireEvent.mouseEnter(carouselSection);
    
    // Avança o temporizador, mas o item não deve mudar
    jest.advanceTimersByTime(1000);
    expect(screen.getByText('Título 1')).toBeInTheDocument();

    // Limpa o temporizador
    jest.useRealTimers();
  });

  it('deve retomar a reprodução automática ao retirar o mouse', async () => {
    jest.useFakeTimers();
    carouselService.getCarouselItems.mockResolvedValueOnce(mockCarouselItems);
    
    render(<Carousel />);
    
    const carouselSection = await screen.findByRole('region');
    
    // Inicia e para a reprodução automática
    fireEvent.mouseEnter(carouselSection);
    fireEvent.mouseLeave(carouselSection);
    
    // Avança o temporizador por 1 segundo
    jest.advanceTimersByTime(1000);
    
    // O item deve ter mudado para o "Título 2"
    await waitFor(() => {
      expect(screen.getByText('Título 2')).toBeInTheDocument();
    }, { timeout: 100 });

    jest.useRealTimers();
  });
  
  it('deve chamar a função do botão "comprar agora"', async () => {
    // Mocka o console para verificar se a mensagem foi logada
    const consoleSpy = jest.spyOn(console, 'log');
    
    carouselService.getCarouselItems.mockResolvedValueOnce(mockCarouselItems);
    render(<Carousel />);

    const comprarAgoraButton = await screen.findByRole('button', { name: /comprar agora/i });
    
    fireEvent.click(comprarAgoraButton);
    
    expect(consoleSpy).toHaveBeenCalledWith('Botão clicado: Comprar Agora!');

    consoleSpy.mockRestore(); // Restaura o console.log original
  });
});
*/
